#include "imports/stdlib.fc";
#include "imports/params.fc";
#include "imports/op-codes.fc";
#include "imports/errors.fc";
#include "imports/storage.fc";
#include "imports/utils.fc";
#include "./admin-calls.fc";
#include "./get.fc";

;; storage variables

;; load_data populates storage variables using stored data


;; recv_internal is the main function of the contract and is called when it receives a message from other contracts
() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) { ;; ignore all empty messages
        return ();
    }

    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    if (flags & 1) { ;; ignore all bounced messages
        return ();
    }
    slice sender_address = cs~load_msg_addr();
    force_chain(sender_address);

    load_storage(); ;; here we populate the storage variables

    int op = in_msg_body~load_uint(32); ;; by convention, the first 32 bits of incoming message is the op
    int query_id = in_msg_body~load_uint(64); ;; also by convention, the next 64 bits contain the "query id", although this is not always the case

    if (equal_slices(storage::admin, sender_address)) {
        handle_admin_messages(op, query_id, in_msg_body);
        return ();
    }

    clean_queries_if_possible();
    check_unlocked();

    if ((op == op::withdraw()) | (op == op::claim())) {
        slice signature = in_msg_body~load_bits(512);
        cell msg_inner = in_msg_body~load_ref();
        in_msg_body.end_parse();
        throw_unless(error::invalid_signature, check_signature(msg_inner.cell_hash(), signature, storage::signer));

        slice msg_inner_slice = msg_inner.begin_parse();
        int shift = msg_inner_slice~load_uint(KEY_SIZE);
        int bit_number = msg_inner_slice~load_uint(BIT_NUMBER_SIZE);
        msg_inner_slice~skip_bits(PROJECT_ID_SIZE);
        int created_at = msg_inner_slice~load_uint(TIMESTAMP_SIZE);
        int jetton_amount = msg_inner_slice~load_coins();
        slice token_address = msg_inner_slice~load_msg_addr();
        slice recipient = msg_inner_slice~load_msg_addr();
        msg_inner_slice.end_parse();

        builder body = create_simple_transfer_body(query_id, 0, jetton_amount, recipient);

        check_expiration(created_at);

        ;; prevent from replay attack
        invalidate_used_query(shift, bit_number);

        ;; send jetton to recipient
        slice vault_jetton_wallet = calculate_user_jetton_wallet_address(my_address(), token_address, storage::jetton_wallet_code);
        send_simple_message(0, vault_jetton_wallet, body.end_cell(), CARRY_REMAINING_GAS);

        save_storage();
        return ();
    }

    if (op == op::transfer_notification()) {
        (int jetton_amount, _) = (in_msg_body~load_coins(), in_msg_body~load_msg_addr());
        cell ref_cs = in_msg_body~load_ref();

        slice ref_ds = ref_cs.begin_parse();
        int transfered_op = ref_ds~load_uint(32);
        var signature = ref_ds~load_bits(SIGNATURE_SIZE);
        cell msg_inner = ref_ds~load_ref();
        ref_ds.end_parse();
        slice msg_inner_slice = msg_inner.begin_parse();

        throw_unless(error::invalid_op, transfered_op == op::deposit());

        ;; verify signature
        throw_unless(error::invalid_signature, check_signature(
                generate_unsigned_deposit_msg_hash(msg_inner_slice, jetton_amount),
                signature, storage::signer)
        );

        int shift = msg_inner_slice~load_uint(KEY_SIZE);
        int bit_number = msg_inner_slice~load_uint(BIT_NUMBER_SIZE);
        msg_inner_slice~skip_bits(PROJECT_ID_SIZE);
        int created_at = msg_inner_slice~load_uint(TIMESTAMP_SIZE);
        slice token_address = msg_inner_slice~load_msg_addr();
        msg_inner_slice.end_parse();

        ;; check expiration
        check_expiration(created_at);

        ;; prevent from replay attack
        invalidate_used_query(shift, bit_number);

        ;; check valid sender from jetton wallet
        throw_unless(error::invalid_sender, equal_slices(calculate_user_jetton_wallet_address(my_address(), token_address, storage::jetton_wallet_code), sender_address));

        save_storage();
        return ();
    }

    throw(0xffff); ;; if the message contains an op that is not known to this contract, we throw
}



